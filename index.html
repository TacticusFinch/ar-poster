<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Сканер постера с подсветкой</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0f14;
      color: #e5f0ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
    }
    .wrap {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 800px at 50% 50%, rgba(40,60,90,.25), transparent 60%);
    }
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* Зеркалим, как фронтальную; уберите, если нужно обычное */
      filter: contrast(1.05) saturate(1.1);
    }
    canvas#overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .hud {
      position: absolute;
      left: 50%;
      bottom: env(safe-area-inset-bottom, 16px);
      transform: translateX(-50%);
      background: rgba(9,13,20,.5);
      border: 1px solid rgba(120,170,255,.25);
      border-radius: 14px;
      padding: 10px 14px;
      backdrop-filter: blur(6px) saturate(1.2);
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
      font-size: 14px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: #ff4d6d;
      box-shadow: 0 0 12px 4px rgba(255,77,109,.6), 0 0 30px 10px rgba(255,77,109,.2);
      animation: pulse 1.4s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(0.9); filter: drop-shadow(0 0 10px #ff4d6d); }
      50% { transform: scale(1.15); filter: drop-shadow(0 0 20px #ffb3c1); }
    }
    .note {
      opacity: .8;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
    <div class="hud">
      <div class="dot" id="statusDot"></div>
      <div id="statusText">Инициализация OCR…</div>
    </div>
  </div>

  <!-- Tesseract.js CDN -->
  <script src="https://unpkg.com/tesseract.js@5.0.5/dist/tesseract.min.js"></script>
  <script>
    // Целевые слова (без регистра)
    const TARGETS = ["играть", "записаться"];

    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const statusText = document.getElementById('statusText');
    const statusDot = document.getElementById('statusDot');

    // Служебный канвас для OCR (умеренное разрешение для скорости)
    const ocrCanvas = document.createElement('canvas');
    const ocrCtx = ocrCanvas.getContext('2d', { willReadFrequently: true });

    let worker;
    let running = false;
    let lastDetections = [];
    let pulseT = 0;

    // Анимация подсветки
    function drawOverlay() {
      const w = overlay.width;
      const h = overlay.height;
      ctx.clearRect(0, 0, w, h);

      // Фоновые мягкие лучи
      const g = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.05, w/2, h/2, Math.max(w,h)*0.8);
      g.addColorStop(0, 'rgba(80,120,255,0.05)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      // Анимированный неон
      const t = (performance.now() / 1000);
      pulseT = (Math.sin(t*2.4) + 1) / 2; // 0..1
      const hueA = (t * 40) % 360;
      const hueB = (hueA + 180) % 360;

      for (const d of lastDetections) {
        const { x, y, w: bw, h: bh, text } = d;

        // Слегка расширим рамку для эффекта
        const pad = Math.max(6, Math.min(bw, bh) * 0.15);
        const rx = x - pad;
        const ry = y - pad;
        const rw = bw + pad*2;
        const rh = bh + pad*2;
        const radius = Math.min(18, Math.max(8, Math.min(rw, rh)*0.2));

        // 1) Внешний "туман" свечения
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowColor = `hsla(${hueA}, 90%, 65%, ${0.22 + pulseT*0.18})`;
        ctx.shadowBlur = 40 + pulseT * 30;
        roundedRect(ctx, rx, ry, rw, rh, radius);
        ctx.strokeStyle = `hsla(${hueB}, 90%, 70%, 0.18)`;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();

        // 2) Неоновая рамка с градиентом
        ctx.save();
        ctx.lineWidth = 3.5;
        const lg = ctx.createLinearGradient(rx, ry, rx+rw, ry+rh);
        lg.addColorStop(0, `hsla(${hueA}, 100%, ${65 + pulseT*10}%, 0.95)`);
        lg.addColorStop(1, `hsla(${hueB}, 100%, ${65 + (1-pulseT)*10}%, 0.95)`);
        ctx.strokeStyle = lg;
        roundedRect(ctx, rx, ry, rw, rh, radius);
        ctx.stroke();
        ctx.restore();

        // 3) Полупрозрачная подложка
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = `hsla(${hueA}, 90%, 55%, ${0.08 + pulseT*0.06})`;
        roundedRect(ctx, rx, ry, rw, rh, radius);
        ctx.fill();
        ctx.restore();

        // 4) Подсветка текста
        ctx.save();
        ctx.font = `${Math.max(14, bh*0.55)}px ui-sans-serif, system-ui, Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.shadowColor = `hsla(${hueA}, 100%, 70%, 0.6)`;
        ctx.shadowBlur = 10 + pulseT*10;
        ctx.fillText(text, x + bw/2, y + bh/2);
        ctx.restore();
      }

      requestAnimationFrame(drawOverlay);
    }

    function roundedRect(ctx, x, y, w, h, r) {
      const r2 = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + r2, y);
      ctx.arcTo(x + w, y, x + w, y + h, r2);
      ctx.arcTo(x + w, y + h, x, y + h, r2);
      ctx.arcTo(x, y + h, x, y, r2);
      ctx.arcTo(x, y, x + w, y, r2);
      ctx.closePath();
    }

    async function initCamera() {
      // Пробуем основную (заднюю) камеру
      const constraints = {
        audio: false,
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();
    }

    async function initOCR() {
      statusText.textContent = 'Загрузка языковых данных…';
      worker = await Tesseract.createWorker({
        logger: m => {
          if (m.status === 'recognizing text') {
            statusText.textContent = `Распознавание… ${Math.round((m.progress || 0)*100)}%`;
          }
        },
        // Подгружаем русские данные
        langPath: 'https://tessdata.projectnaptha.com/4.0.0',
      });
      await worker.loadLanguage('rus');
      await worker.initialize('rus');
      await worker.setParameters({
        tessedit_char_whitelist: 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюяABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-–—+',
        preserve_interword_spaces: '1'
      });
      statusText.textContent = 'Готово. Наведите камеру на постер.';
      statusDot.style.background = '#4dff9a';
      statusDot.style.boxShadow = '0 0 14px 6px rgba(77,255,154,.6), 0 0 30px 10px rgba(77,255,154,.25)';
    }

    function resizeCanvases() {
      const rect = video.getBoundingClientRect();
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      overlay.width = Math.floor(rect.width * dpr);
      overlay.height = Math.floor(rect.height * dpr);
      // OCR канвас — понижаем для скорости (регулируйте под устройство)
      const base = 1024; // ширина для OCR
      const aspect = video.videoHeight ? video.videoWidth / video.videoHeight : (rect.width / rect.height);
      ocrCanvas.width = base;
      ocrCanvas.height = Math.max(512, Math.round(base / (aspect || 1.777)));
    }

    // Сопоставление координат из OCR-канваса в overlay
    function mapBox(bbox) {
      // bbox: { x0, y0, x1, y1 } в координатах ocrCanvas
      const sx = overlay.width / ocrCanvas.width;
      const sy = overlay.height / ocrCanvas.height;

      // Видеопоток может быть зеркален по X (мы зеркалим video через CSS).
      // Для соответствия подсветки — отражаем по X.
      const x0 = ocrCanvas.width - bbox.x1; // зеркалим
      const x1 = ocrCanvas.width - bbox.x0;

      return {
        x: x0 * sx,
        y: bbox.y0 * sy,
        w: (x1 - x0) * sx,
        h: (bbox.y1 - bbox.y0) * sy
      };
    }

    async function scanLoop() {
      if (!running) return;

      // 1) Рисуем текущий кадр в OCR-канвас
      ocrCtx.save();
      // Отразим по X, чтобы OCR видел немзеркальное изображение
      ocrCtx.scale(-1, 1);
      ocrCtx.drawImage(video, -ocrCanvas.width, 0, ocrCanvas.width, ocrCanvas.height);
      ocrCtx.restore();

      try {
        const { data } = await worker.recognize(ocrCanvas);
        // Собираем подходящие слова
        const found = [];
        const words = data.words || [];
        for (const w of words) {
          const text = (w.text || '').trim();
          if (!text) continue;
          const lower = text.toLowerCase();
          if (TARGETS.includes(lower)) {
            const box = mapBox(w.bbox);
            // Фильтруем очень маленькие боксы (шум)
            if (box.w > 20 && box.h > 12) {
              found.push({ ...box, text });
            }
          }
        }
        lastDetections = found;
        statusText.textContent = found.length
          ? `Найдено: ${found.map(f => f.text).join(', ')}`
          : 'Сканирование…';
      } catch (err) {
        console.error(err);
        statusText.textContent = 'Ошибка OCR. Повтор…';
      }

      // Частота OCR: ~2 Гц для мобильных (регулируйте)
      setTimeout(scanLoop, 450);
    }

    async function main() {
      try {
        await initCamera();
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);
        requestAnimationFrame(drawOverlay);
        await initOCR();
        running = true;
        scanLoop();
      } catch (e) {
        console.error(e);
        statusText.textContent = 'Нет доступа к камере или ошибка инициализации.';
        statusDot.style.background = '#ff4d6d';
      }
    }

    document.addEventListener('DOMContentLoaded', main);
  </script>
</body>
</html>